### Trie.字符串统计

用数组模拟字符串
![](2025-11-24-13-38-44.png)
```cpp
#include<iostream>
using namespace std;
const int N=100010;
int son[N][26],cnt[N],idx=0;
void insert(string s){
    int p=0;
    for(int i=0;s[i];i++){
        int u=s[i]-'a';
        if(!son[p][u])son[p][u]=++idx;
        p=son[p][u];
    }
    cnt[p]++;
}
int query(string s){
    int p=0;
    for(int i=0;s[i];i++){
        int u=s[i]-'a';
        if(!son[p][u])return 0;
        p=son[p][u];
    }
    return cnt[p];
}
int main(){
    int n;
    cin>>n;
    while(n--){
        string s;
        cin>>s;
        insert(s);
    }
    int m;
    cin>>m;
    while(m--){
        string s;
        cin>>s;
        cout<<query(s)<<endl;
    }
    return 0;
}
```

例题力扣2977
trie + floyd

![](2026-01-30-21-27-11.png)

用sid 重新编号，放弃idx大多数无意义的编号
```cpp

class Solution {
public:
    long long minimumCost(string source, string target, vector<string>& original, vector<string>& changed, vector<int>& cost) {
        //建树
        const int N = 10010;
        int son[N][26],id[N],idx = 0,sid = 0; 
        memset(id,-1,sizeof id);
        memset(son,0,sizeof son);
        auto up = [&](string& s){//将插入和查询操作合并
            int p = 0;
            for(int i = 0; i < s.size(); i++){
                int u = s[i] - 'a';
                if(!son[p][u]) son[p][u] = ++idx;
                p = son[p][u];
            }
            if(id[p] == -1) id[p] = sid++;
            return id[p];
        };

        long long dis[200][200];
        int INF = INT_MAX;
        memset(dis,0x3f,sizeof dis);
        for(int i = 0; i < 110; i++){
            dis[i][i] = 0;
        }
        for(int i = 0; i < cost.size(); i++){
            int x = up(original[i]);
            int y = up(changed[i]);
            dis[x][y] = min(dis[x][y],(long long)cost[i]);
        }//sid更新完毕，sid为字符串的数量


        for(int k = 0; k < sid; k++){//经典floyd
            for(int i = 0; i < sid; i++){
                if(dis[i][k] == INF)continue;
                for(int j = 0; j < sid; j++){
                    dis[i][j] = min(dis[i][j],dis[i][k] + dis[k][j]);
                }
            }
        }

         int n = source.size();
         vector<long long> memo(n,-1);//记忆化搜索
         const long long INF_LL = 1e12;


        //dp[i]表示source[i]的最小成本
         auto dfs = [&](this auto&& dfs,int i) -> long long{
            if(i >= n)return 0;
            if(memo[i] != -1)return memo[i];
            long long res = INF_LL;
            if(source[i] == target[i])res = dfs(i+1);

            int curp = 0,curq = 0; //curp表示source[i]的trie节点，curq表示target[i]的trie节点
            for(int j = i; j < n; j++){
                int u_p = source[j] - 'a';
                int u_q = target[j] - 'a';
                if(!son[curp][u_p] || !son[curq][u_q])break;
                curp = son[curp][u_p];
                curq = son[curq][u_q];
                if(id[curp] == -1 || id[curq] == -1)continue;
                int x = id[curp],y = id[curq];
                if(dis[x][y] == INF)continue;
                res = min(res,dis[x][y] + dfs(j + 1));  //dis[x][y]表示 source 从x到y改变的最小成本
            }
            memo[i] = res;
            return res;
         };
         long long ans = dfs(0);
         return ans < INF_LL ? ans : -1;

    }
};

```