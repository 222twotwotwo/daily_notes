
### 陨石

![](2025-12-15-15-01-27.png)
```cpp
#include<iostream>
#include<queue>
#include<algorithm>
#include<cstring>
using namespace std;

int mp[310][310],st[310][310];
int d1[4]={-1,0,1,0},d2[4]={0,1,0,-1};

struct point{
    int x,y,cnt;
};

int bfs(point u){
    queue<point>q;
    q.push(u);
    st[u.x][u.y]=1;
    while(!q.empty()){
        point v = q.front();
        q.pop();
        for(int i=0;i<4;i++){
            int a=v.x+d1[i],b=v.y+d2[i],c=v.cnt+1;
            if(a<0 || b<0 || st[a][b] || mp[a][b]<=c)continue;
            if(a>301 || b>301 || mp[a][b]==0x3f3f3f3f)return c;
            q.push({a,b,c});
            st[a][b]=1;
        }
    }
        return -1;
}


int main(){
    memset(mp,0x3f,sizeof mp);
    int m;
    scanf("%d",&m);
    int x,y,t;
    for(int i=0;i<m;i++){
        scanf("%d%d",&x,&y);
        scanf("%d",&t);
        mp[x][y]=min(mp[x][y],t);
        for(int i=0;i<4;i++){
            if(x-d1[i]<0 || y-d2[i]<0)continue;
            mp[x-d1[i]][y-d2[i]]=min(t,mp[x-d1[i]][y-d2[i]]);
        }
    }
    printf("%d",bfs({0,0,0}));
    return 0;
}

```
![](2025-12-15-16-26-07.png)



### 迷宫

![](2025-12-15-17-39-08.png)


```cpp
#include<iostream>

using namespace std;
const int N=110;
int res=0,st[N][N],n,m,fx,fy;

void dfs(int u,int v){
    if(st[u][v] || u<1 || v<1 || u>m || v>n)return ;
    if(u==fx && v==fy){
        res++;
        return ;
    }
    st[u][v]=1;
    dfs(u+1,v);
    dfs(u-1,v);
    dfs(u,v+1);
    dfs(u,v-1);
    st[u][v]=0;
    
}

int main(){
    int t;
    scanf("%d%d%d",&n,&m,&t);
    int sx,sy;
    scanf("%d%d%d%d",&sx,&sy,&fx,&fy);
    int x,y;
    while(t--){
        scanf("%d%d",&x,&y);
        st[x][y]=1;
    }
    dfs(sx,sy);
    printf("%d",res);
    return 0;
}


```


### 皇后

![](2025-12-15-19-23-45.png)
```cpp
#include<iostream>
using namespace std;
const int N=50;
int n,h[N][N],col[N],dg[N],udg[N],res=0,cnt=0;
void dfs(int u){
    if(u==n+1){
        res++;
        if(cnt!=3){
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                if(h[i][j]!=0)printf("%d ",j);
            }
        }
        puts("");
        cnt++;
        }
        return ;
    }
    for(int i=1;i<=n;i++){
        if(!col[i] && !dg[u+i] && !udg[u-i+n]){
            col[i]=1,dg[u+i]=1,udg[u-i+n]=1;
            h[u][i]=1;
            dfs(u+1);
            h[u][i]=0;
            col[i]=0,dg[u+i]=0,udg[u-i+n]=0;
        }
        
    }
    
}


int main(){
    scanf("%d",&n);
    dfs(1);
    printf("%d",res);
    return 0;
}
```



### 陨石

![](2025-12-15-15-01-27.png)
```cpp
#include<iostream>
#include<queue>
#include<algorithm>
#include<cstring>
using namespace std;

int mp[310][310],st[310][310];
int d1[4]={-1,0,1,0},d2[4]={0,1,0,-1};

struct point{
    int x,y,cnt;
};

int bfs(point u){
    queue<point>q;
    q.push(u);
    st[u.x][u.y]=1;
    while(!q.empty()){
        point v = q.front();
        q.pop();
        for(int i=0;i<4;i++){
            int a=v.x+d1[i],b=v.y+d2[i],c=v.cnt+1;
            if(a<0 || b<0 || st[a][b] || mp[a][b]<=c)continue;
            if(a>301 || b>301 || mp[a][b]==0x3f3f3f3f)return c;
            q.push({a,b,c});
            st[a][b]=1;
        }
    }
        return -1;
}


int main(){
    memset(mp,0x3f,sizeof mp);
    int m;
    scanf("%d",&m);
    int x,y,t;
    for(int i=0;i<m;i++){
        scanf("%d%d",&x,&y);
        scanf("%d",&t);
        mp[x][y]=min(mp[x][y],t);
        for(int i=0;i<4;i++){
            if(x-d1[i]<0 || y-d2[i]<0)continue;
            mp[x-d1[i]][y-d2[i]]=min(t,mp[x-d1[i]][y-d2[i]]);
        }
    }
    printf("%d",bfs({0,0,0}));
    return 0;
}

```
![](2025-12-15-16-26-07.png)


### 爬楼梯
![](2025-12-15-20-14-57.png)

记忆缓存
```cpp
class Solution {
public:
int memo[1001];
    int climbStairs(int n) {
        auto dfs = [&](this auto&& dfs ,int i){
            if(i-1==0)return 1;
            if(i-2==0)return 2;
            int& res = memo[i];
            if(res){
                return res;//直接返回就不用进行递归了
            }
            return res=dfs(i-1)+dfs(i-2);//存储已经计算过的结果
        };
        return res=dfs(n);
    }
};

```


### 快速幂

![](2025-12-15-22-22-53.png)
使用二进制附带加法的方式进行理解

1 1 1 0 1 0
可以表示成
1 0 0 0 0 0
  1 0 0 0 0
    1 0 0 0
      0 1 0
相加
这便是为什么任意一个数可以用2的幂和表示
将n看作任意一个数就可以将结论拓展到这里


```cpp

class Solution {
public:
    double myPow(double x, long long n) {
        double ans=1;
        if(n<0){
            x=1/x;
            n=-n;
        }
        while(n){
            if(n & 1){
                ans *= x;
            }
            x*=x;
            n>>=1;
        }
        return ans;
    }
};

```