
### 电梯
![](2025-12-14-15-23-36.png)
使用dfs走完全程，记录每个楼层的最小步数，最后输出B的最小步数即可
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1010;
int k[N],dist[N];//设置楼层和标记数组
int B,n;//res=MAX_INT
void dfs(int u,int cnt){
    dist[u]=cnt;
    int v=u+k[u];
    if(v<=n && dist[v] > cnt+1)dfs(v,cnt+1);
    v=u-k[u];
    if(v>0 && dist[v] >cnt+1)dfs(v,cnt+1);
    return ;
}

int main(){
    memset(dist,0x3f,sizeof dist);
    int A;
    scanf("%d%d%d",&n,&A,&B);
    for(int i=1;i<=n;i++){
        scanf("%d",&k[i]);
    }
    dfs(A,0);
    int res=dist[B];
    if(res == 0x3f3f3f3f)res=-1;
    printf("%d",res);
    return 0;
}

```

使用bfs走完全程，记录每个楼层的最小步数，最后输出B的最小步数即可

```cpp

#include<iostream>
#include<queue>
#include<cstring>
using namespace std;

const int N=1010;
int dist[N],k[N];
int n,a,b;

int main(){
    memset(dist ,0x3f,sizeof dist);
    scanf("%d%d%d",&n,&a,&b);
    for(int i=1;i<=n;i++){
        scanf("%d",&k[i]);
    }
    dist[a]=0;
    auto bfs = [&](){
        queue<int>q;
        q.push(a);
        while(!q.empty()){
            int u=q.front();
            q.pop();
            int v=u+k[u];
            if(v<=n && dist[v]>dist[u]+1){
                dist[v]=dist[u]+1;
                q.push(v);
            }
            v=u-k[u];
            if(v>0 && dist[v]>dist[u]+1){
                dist[v]=dist[u]+1;
                q.push(v);
            }
        }
    };
    bfs();
    if(dist[b]==0x3f3f3f3f)puts("-1");
    else printf("%d",dist[b]);
    return 0;
}
```








### 马的遍历
![](2025-12-14-15-23-12.png)
```cpp
#include<iostream>
#include<utility>
#include<cstring>
#include<vector>
#include<queue>
using namespace std;
const int N=410;
int n,m,x,y;

int main(){
    scanf("%d%d%d%d",&n,&m,&x,&y);
    vector<vector<int>>dist(n+1,vector<int>(m+1,1e9));
    dist[x][y]=0;
    queue<pair<int,int>>q;
    q.push({x,y});
    while(!q.empty()){
        int u=q.front().first;
        int v=q.front().second;
        q.pop();
        x = u - 2, y = v +1;
        if(x>0 && y <= m && dist[x][y]>dist[u][v]+1){
            dist[x][y]=dist[u][v]+1;
            q.push({x,y});
        }
        x = u - 2, y = v -1;
        if(x>0 && y > 0 && dist[x][y]>dist[u][v]+1){
            dist[x][y]=dist[u][v]+1;
            q.push({x,y});
        }
        x = u + 2, y = v +1;
        if(x<=n && y <= m && dist[x][y]>dist[u][v]+1){
            dist[x][y]=dist[u][v]+1;
            q.push({x,y});
        }
                x = u + 2, y = v -1;
        if(x<=n && y > 0 && dist[x][y]>dist[u][v]+1){
            dist[x][y]=dist[u][v]+1;
            q.push({x,y});
        }
                x = u - 1, y = v +2;
        if(x>0 && y <= m && dist[x][y]>dist[u][v]+1){
            dist[x][y]=dist[u][v]+1;
            q.push({x,y});
        }
                x = u - 1, y = v -2;
        if(x>0 && y > 0 && dist[x][y]>dist[u][v]+1){
            dist[x][y]=dist[u][v]+1;
            q.push({x,y});
        }
                x = u + 1, y = v +2;
        if(x<=n && y <= m && dist[x][y]>dist[u][v]+1){
            dist[x][y]=dist[u][v]+1;
            q.push({x,y});
        }
                x = u + 1, y = v -2;
        if(x<=n && y > 0 && dist[x][y]>dist[u][v]+1){
            dist[x][y]=dist[u][v]+1;
            q.push({x,y});
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(dist[i][j]==1e9)dist[i][j]=-1;
            printf("%d ",dist[i][j]);
        }
    }
    return 0;

    
}

```
实现优化

```cpp
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;

const int N = 410;
// 马的8个方向向量（dx, dy）：核心，避免重复/遗漏
int dirs[8][2] = {
    {-2, 1}, {-2, -1},
    {2, 1},  {2, -1},
    {-1, 2}, {-1, -2},
    {1, 2},  {1, -2}
};

int main() {
    int n, m, sx, sy;  // 用sx/sy存储起点，避免覆盖
    scanf("%d%d%d%d", &n, &m, &sx, &sy);
    
    // 初始化距离数组：0x3f3f3f3f表示无穷大（不可达）
    int dist[N][N];
    memset(dist, 0x3f, sizeof dist);
    dist[sx][sy] = 0;  // 起点步数为0
    
    queue<pair<int, int>> q;
    q.push({sx, sy});
    
    // BFS核心：队列非空时遍历
    while (!q.empty()) {
        auto [u, v] = q.front();
        q.pop();
        
        // 遍历8个方向
        for (int i = 0; i < 8; i++) {
            int nx = u + dirs[i][0];
            int ny = v + dirs[i][1];
            // 边界判断 + 更短路径判断
            if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && dist[nx][ny] > dist[u][v] + 1) {
                dist[nx][ny] = dist[u][v] + 1;
                q.push({nx, ny});
            }
        }
    }
    
    // 按要求输出：1~n行，1~m列，不可达输出-1
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (dist[i][j] == 0x3f3f3f3f) {
                printf("-1 ");
            } else {
                printf("%d ", dist[i][j]);
            }
        }
        printf("\n");  // 每行结束换行
    }
    
    return 0;
}
```

### 染色判定二分图
![](2025-12-14-17-46-24.png)
```cpp
#include<iostream>

using namespace std;

const int N=1e5+10;
const int M=2*N;
int h[N],e[M],ne[M],idx=0;
int color[N]={};

void add(int a,int b){
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
    e[idx]=a;
    ne[idx]=h[b];
    h[b]=idx++;
}


bool dfs(int u,int c){
    color[u]=c;
    for(int i=h[u];i!=-1;i=ne[i]){
        int j=e[i];
        if(!color[j]){
            if(!dfs(j,3-c))return false;
        }
        else if(color[j]==c)return false;
    }
    return true;
}


int main(){
    memset(h,-1,sizeof h);
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=0;i<m;i++){
        int a,b;
        scanf("%d%d",&a,&b);
        add(a,b);
    }
//还需要分析连通情况
    bool flag=true;
    for(int i=1;i<=n;i++){
        if(!color[i]){
            if(!dfs(i,1)){
                flag=false;
                break;
            }
        }
    }
    if(flag){
        printf("Yes\n");
    }
    else{
        printf("No\n");
    }
}

```

### 二分图的最大匹配（匈牙利算法
![](2025-12-14-21-35-43.png)
```cpp
#include<iostream>
#include<cstring>
using namespace std;
const int N=510;
const int M=N*2;
int h[N],e[M],ne[M],idx=0;
int st[N]={};
int match[N]={};

void add(int a,int b){
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}

bool find(int u){
    for(int i=h[u];i!=-1;i=ne[i]){
        int j=e[i];
        if(!st[j]){
            st[j]=1;
            if(!match[j] || find(match[j])){
                match[j]=u;
                return true;
            }

            
        }
    }
    return false;
}
int main(){
    memset(h,-1,sizeof h);
    int n,m;
    scanf("%d%d",&n,&m);
    int u,v;
    while(m--){
    scanf("%d%d",&u,&v);
    add(u,v);
    }
    int res=0;
    for(int i=1;i<=n;i++){
        memset(st,0,sizeof st);
        if(find(i))res++;
    }
    printf("%d\n",res);
    return 0;
}
```