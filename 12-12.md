### 最小生成树/prim

![](2025-12-02-14-15-31.png)

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1010;
int g[N][N],st[N],dist[N];
int prim(){
    memset(dist,0x3f,sizeof dist);
    int res=0;
    dist[1]=0;
    for(int i=0;i<n;i++){
        int t=-1;
        for(int j=1;j<=n;j++){
            if(!st[j] && (t==-1 || dist[j]<dist[t]))
            t=j;
        }

        if(i && dist[t]==0x3f3f3f3f)return 0x3f3f3f3f;

        res+=dist[t];
        st[t]=1;

        for(int j=1;j<=n;j++)
            dist[j]=min(dist[j],g[t][j]);

    }
    return res;
}
int main(){
    cin.tie(0);
    cout.tie(0);
    ios::sync_with_stdio(0);

    memset(g,0x3f,sizeof g);
    //fill(g[0],g[0]+N*N,0x3f3f3f3f);
    int n,m;
    cin>>n>>m;

    while(m--){
        int u,v,w;
        cin>>u>>v>>w;
        g[u][v]=g[v][u]=min(g[u][v],w);
    }
    int res=prim();
    if(res==0x3f3f3f3f)puts("impossible");
    else cout<<res<<"\n";

    
}

#include<iostream>
#include<algorithm>
#include<cstring>  // 补充memset所需头文件
using namespace std;

// 朴素版Prim适配的N（n≤1000），避免内存爆炸
const int N=1010;
int g[N][N], st[N], dist[N];
const int INF=0x3f3f3f3f;
int n, m;  // 全局声明，让prim函数可访问

int prim(){
    memset(dist, 0x3f, sizeof dist);
    int res = 0;
    for(int i=0; i<n; i++){  // 循环n次选节点
        int t = -1;
        // 找未选且dist最小的节点
        for(int j=1; j<=n; j++){
            if(!st[j] && (t==-1 || dist[j]<dist[t])){
                t = j;
            }
        }

        // 非第一个节点且dist[t]=INF → 图不连通
        if(i && dist[t]==INF) return INF;

        // 松弛操作：用t更新所有节点的dist
        for(int j=1; j<=n; j++){
            dist[j] = min(dist[j], g[t][j]);
        }

        // 第一个节点无父边，跳过累加（避免加INF）
        if(i != 0) res += dist[t];
        st[t] = 1;
    }
    return res;
}

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    // 初始化邻接矩阵为INF
    memset(g, 0x3f, sizeof g);
    // 初始化自环：节点自身到自身的边权为0
    cin >> n >> m;
    for(int i=1; i<=n; i++){
        g[i][i] = 0;
    }

    // 输入m条无向边，处理重边（取最小权值）
    while(m--){
        int u, v, w;
        cin >> u >> v >> w;
        g[u][v] = g[v][u] = min(g[u][v], w);
    }

    int res = prim();
    if(res == INF) puts("impossible");
    else cout << res << "\n";

    return 0;
}
```


### 前向星bfs`
![](2025-12-11-15-47-53.png)
![](2025-12-11-15-48-05.png)
https://www.luogu.com.cn/problem/CF2172M
```cpp
#include<cstdio>   // 必须包含scanf/printf的头文件
#include<cstring>
#include<queue>
using namespace std;

const int N=200010;
const int M=2*N;
int h[N],e[M],ne[M],idx=0;
int dist[N],a[N],ans[N],n,m,k;

void add(int u,int v){
    e[idx]=v;
    ne[idx]=h[u];
    h[u]=idx++;
    
    e[idx]=u;
    ne[idx]=h[v];
    h[v]=idx++;
}

void bfs(){
    queue<int>q;
    memset(dist,-1,sizeof dist);
    dist[1]=0;
    q.push(1);
    
    while(!q.empty()){
        int u=q.front();
        q.pop();
        // register优化：减少内存访问开销
        for(register int i=h[u];i!=-1;i=ne[i]){
            int v=e[i];
            if(dist[v]==-1){
                dist[v]=dist[u]+1;
                q.push(v);
            }
        }
    }
}

int main(){
    memset(h,-1,sizeof h);
    scanf("%d%d%d", &n, &m, &k);
    for(int i=1;i<=n;i++){
        scanf("%d", &a[i]);
    }
    int u,v;
    for(int i=0;i<m;i++){
        scanf("%d%d", &u, &v);
        add(u,v);
    }
    bfs();
    memset(ans,-1,sizeof ans);
    for(int i=1;i<=n;i++){
        int obj=a[i];
        if(dist[i]!=-1){
            ans[obj]=max(ans[obj],dist[i]);
        }
    }
    for(int i=1;i<=k;i++){
        printf("%d", ans[i]);
        if(i!=k) printf(" ");
    }
    return 0;
}
```

### 炸铁路
https://www.luogu.com.cn/problem/P1656#ide
![](2025-12-11-22-26-26.png)

并查集枚举解决

```cpp
#include<iostream>
#include<vector>
#include<utility>
#include<algorithm>
using namespace std;
const int N=100010;
struct DSU{

    int p[N];
    DSU(int n){
        for(int i=1;i<=n;i++)p[i]=i;
    }
    int find(int x){
        while(p[x]!=x){
            p[x]=p[p[x]];
            x=p[x];
        }
        return x;
    }
    void merge(int a,int b){
        p[find(a)]=find(b);
    }

};



int main(){

    vector<pair<int,int>>e;
    int n,m;
    scanf("%d%d",&n,&m);
    int a,b;
    for(int i=0;i<m;i++){
        scanf("%d%d",&a,&b);
        e.emplace_back(a,b);
    }
    vector<pair<int ,int>>res;
    for(int i=0;i<m;i++){
        int f=e[i].first,s=e[i].second;
        DSU dsu(n);
        for(int j=0;j<m;j++){
            if(j==i)continue;
            dsu.merge(e[j].first,e[j].second);
        }
        int root=dsu.find(1);
        for(int k=2;k<=n;k++){
            if(dsu.find(k)!=root){
                if(f>s)swap(f,s);
                res.emplace_back(f,s);
                break;
            }
        }
    }
    sort(res.begin(),res.end());
    for(auto p : res){
        printf("%d %d\n",p.first,p.second);
    }
    return 0;
}

```
![](2025-12-12-14-11-30.png)

### kruskal 最小生成树

![](2025-12-12-16-27-32.png)

```cpp
#include<iostream>
#include<algorithm>

using namespace std;
const int N=100010;
int p[N],n,m;

struct edges{
    int u,v,w;
    bool operator<(const edges& e)const{
        return w<e.w;
    }
}edge[N];

int find(int x){
    while(p[x]!=x){
        p[x]=p[p[x]];
        x=p[x];
    }
    return x;
}

int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        p[i]=i;
    }
    int u,v,w;
    for(int i=0;i<m;i++){
        scanf("%d%d%d",&u,&v,&w);
        edge[i]={u,v,w};
    }
    sort(edge,edge+m);
    int res=0,cnt=0;
    for(int i=0;i<m;i++){
        u=edge[i].u,v=edge[i].v,w=edge[i].w;
        int a=find(u),b=find(v);
        if(a!=b){
            p[a]=b;
            res+=w;
            cnt++;
        }
    }
    if(cnt!=n-1)puts("impossible");
    else printf("%d",res);
}

```

### 买礼物

![](2025-12-12-17-08-49.png)

```cpp

#include<iostream>
#include<algorithm>

using namespace std;
const int N=510 * 510;
//kruskal
int p[N],u,v,w;
int find(int x){
    while(x!=p[x]){
    p[x]=p[p[x]];
    x=p[x];
    }
    return x;
}
struct edges{
    int u,v,w;
    bool operator<(const edges &e)const{
        return w<e.w;
    }
}edge[N];
int main(){
    
    int A,B;
    scanf("%d%d",&A,&B);
    for(int i=0;i<=B;i++)p[i]=i;
    int idx=0;
    for(int i=1;i<=B;i++){
    edge[idx++]={0,i,A};
    }
    int k;
    for(int i=1;i<=B;i++){
        for(int j=1;j<=B;j++){
        scanf("%d",&k);
        if(i==j)continue;
        int WA=((k==0) ? A : k);    
        edge[idx++]={i,j,WA};
        }
    }
    sort(edge,edge+idx);
    int res=0,cnt=0;
    for(int i=0;i<idx;i++){
        u=find(edge[i].u);
        v=find(edge[i].v);
        if(u!=v){
        p[u]=v;
        res+=edge[i].w;
        cnt++;
        if(cnt==B)break;
        }
    }
    printf("%d",res);
    return 0;
}
```
需注意价格陷阱 ： 一根玉米三块钱，三根玉米十块钱
![](2025-12-12-19-17-16.png)