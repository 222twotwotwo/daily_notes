### 01无尽背包

快速幂替代pow

将获得的总和可以抽象为
二项式表达

![](2025-12-19-16-13-23.png)


```cpp


#include<iostream>
using namespace std;
int n,p;
long long tmp,res=1;
long long m=998244353;
long long quick(long long a,long long b){
  long long ans=1;
  while(b){
    if(b & 1)ans = ans * a % m;
    a = a * a % m;
    b >>= 1;
  }
  return ans ;
}
int main(){
  scanf("%d%d",&n,&p);
  for(int i=0;i<n;i++){
    scanf("%lld",&tmp);
    tmp = quick(p,tmp);
    res = ( res * ( tmp + 1 ) ) % m;
  }
  printf("%lld",res);
  return 0;
}


```



### 01背包问题

![](2025-12-19-16-14-43.png)

首先看暴力

```cpp
#include<iostream>
using namespace std;
const int N=1010;
int n,v[N],w[N];
int res=INT_MIN;
void dfs(int u,int vv,int ww){
    if(u==n){
        res=max(res,ww);
        return;
    }
    dfs(u+1,vv+v[u],ww+w[u]);
    dfs(u+1,vv,ww);
}
int main(){
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        scanf("%d%d",&v[i],&w[i]);
    }
    dfs(0,0,0);
    printf("%d",res);
    return 0;
}
```

时间复杂度来到O(2^n)主要是dfs

接下来看优化

```cpp
#include<iostream>
#include<cstring>
using namespace std;
const int N=1010;
int W[N],V[N],dp[N][N],max_w,n;
int main(){
//获取数据
    scanf("%d%d",&n,&max_w);
    for(int i =0 ; i<n;i++){
        scanf("%d%d",&W[i],&V[i]);
    }

//初始化dp
//dp[物品数量][已经装下物品的体积] = 价值
    memset(dp,0,sizeof dp);
    for(int i =0 ; i<=max_w;i++){
        if(i>=W[0])dp[0][i]=V[0];
    }
//规划全局最优
    for(int i = 1 ; i<n ; i++){
        for(int j = 1 ;j<=max_w ; j++){
            dp[i][j] = dp[i-1][j];
            if(j>=W[i])dp[i][j]=max(dp[i][j],dp[i-1][j-W[i]]+V[i]);
        }
    }
//此时dp[i][j]表示前i个物品中，体积不超过j的最大价值
//最后答案为dp[n-1][max_w]
    printf("%d",dp[n-1][max_w]);
    return 0;
}



```